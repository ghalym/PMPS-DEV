<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.12">
  <POU Name="FB_LinearGovernor" Id="{ef40f951-1e56-0d26-34ec-87da9b08d3b7}" SpecialFunc="None">
    <Declaration><![CDATA[
(* The governor is meant to check your work and keep you from making mistakes.

Checks:
Does your state match the device position and visa versa?
Are the beam parameters safe for the device state?
Did you properly assert the transition and final beam parameters?

*)
FUNCTION_BLOCK FB_LinearGovernor
VAR_INPUT
	i_stCurrentBeamParams	:	ST_BeamParams; //Link to global beam params
	i_xMPSOverride			:	BOOL; //True releases MPS limits after a delay
	i_xTransitionRequested	:	BOOL; //Set true to request a transition
	i_xResetMPSFault	:	BOOL; //Set true to clear MPS fault 
END_VAR
VAR_OUTPUT
	q_xTransitionPermitted	:	BOOL; //True when governor has released restrictions
	q_xFault	:	BOOL; //Set if MC_Power has an error, or override mode is requested
END_VAR
VAR_IN_OUT
	stDevice	:	ST_Device; //The governed
	Arbiter	:	FB_Arbiter;
END_VAR
VAR
	mcPower	:	MC_Power;
	
	xActuatorPositiveEnable: BOOL;
	xActuatorNegativeEnable: BOOL;
	
	xMPSPositiveEnable	:	BOOL;
	xMPSNegativeEnable	:	BOOL;
	lrPosition: LREAL;
	
	lrLatchedTargetPosition	:	LREAL;
	lrLatchedTargetTolerance	:	LREAL;
	
	lrMPSUpperLimit: LREAL;
	lrMPSLowerLimit: LREAL;
	rtNewState: R_TRIG;
	xTransitionOK: BOOL;
	
	tonMPSOverrideMode	:	TON := (
		PT := T#5S
	);
	
	srMPSFault	:	SR;
	// Actuator out of bounds fault
	xActuatorOOB: BOOL;
	//Beam parameters out of spec
	xBeamParamsOOS: BOOL;
	//Beam parameters of currently latched state
	
	stLatchedBeamParams: ST_BeamParams;
	stTargetState: ST_DeviceState;
	
	rtLatchNewState	:	R_TRIG;
	xInit: BOOL := TRUE;
	
	stInitDeviceState: ST_DeviceState;
	// Indicates an error with initialization
	xInitFault: BOOL;
	// Indicates the state could not be found in the state table. There may be something wrong in the device state machine implementation or state table instantiation.
	xStateLookupError: BOOL;
	// Failure to restore state at init
	xInitRestoreStateFail: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
lrPosition := stDevice.stAxis.NcToPlc.ActPos; //Actuator position

stDevice.stAxis.ReadStatus();


(* Initialization
Devices must be restored to any known state, with an active
beam parameter set before their MPS faults can be reset. 
*)
IF xInit THEN
	xInit := FALSE;
	
	//Attempt to restore to previously active state
	//TODO this might be a bad idea, and may need to be avoided
	stDevice.StateTable.A_Lookup(key := stDevice.nActiveState);
	IF stDevice.StateTable.bOk THEN
		stInitDeviceState := stDevice.StateTable.getValue;
		xInitRestoreStateFail := FALSE;
	ELSE
		xInitRestoreStateFail := TRUE;
	END_IF
	
	lrLatchedTargetPosition := stInitDeviceState.rPosition;
	lrLatchedTargetTolerance := stInitDeviceState.rTolerance;
	stLatchedBeamParams := stInitDeviceState.stReqBeamParam;
	
	//Init fault summary
	xInitFault := xInitRestoreStateFail;
END_IF

// The governor will permit transitions once it verifies the transition assertion is active
// Note the governor does not verify the target state beam params are asserted, perhaps it should <TODO>
IF i_xTransitionRequested THEN
	Arbiter.A_VerifyAssertion(
		i_nStateID := stDevice.stTransitionState.nStateRef
	);
	xTransitionOK := Arbiter.q_xStateIDFound AND F_SafeBPCompare(PMPS_GVL_BeamParams.stCurrentBeamParameters, stDevice.stTransitionState.stReqBeamParam);
	
	//Set the target state for evaluation in further logic
	stdevice.StateTable.A_Lookup(key := stDevice.nTargetState);
	IF stDevice.StateTable.bOk THEN
		stTargetState := stDevice.StateTable.getValue;
		xStateLookupError := FALSE;
	ELSE
		xStateLookupError := TRUE;
	END_IF
ELSE
	xTransitionOK := FALSE;
END_IF

(* Note about TransitionRequested

If TransitionRequested goes false during a transition, an MPS fault may be induced. This occurs
because the Actuator Out of Bounds fault will go back to using the original state limits, which
the axis may have already moved beyond.

To avoid this transient fault, make sure your device state machine is implemented such that the 
transition request to the governor block remains high until the target position is reached.
*)

//Determine if a transition is complete and latch the new state
(* A transition is complete when:

Axis at standstill.
Axis within tolerance.
No transition req.

Once these conditions are met, the MPS limits shall re-engage to restrict the
axis motion to the tolerance around the state position and the MPS fault monitors
shall evaluate based on the newly latched target state.
*)

rtLatchNewState(CLK := stDevice.stAxis.Status.StandStill AND
	lrPosition <= stTargetState.rPosition + stTargetState.rTolerance AND
	lrPosition >= stTargetState.rPosition - stTargetState.rTolerance AND
	NOT i_xTransitionRequested);
	
IF rtLatchNewState.Q THEN
	lrLatchedTargetPosition := stTargetState.rPosition;
	lrLatchedTargetTolerance := stTargetState.rTolerance;
	stLatchedBeamParams := stTargetState.stReqBeamParam;
END_IF

//Let other blocks know the governor won't interfer with transitions
q_xTransitionPermitted := xTransitionOK;

//Adjust limit ranges based on active state and current target
IF xTransitionOK THEN
	//Extend range to include target state
	lrMPSUpperLimit := MAX(lrMPSUpperLimit, stTargetState.rPosition + stTargetState.rTolerance);
	lrMPSLowerLimit := MIN(lrMPSLowerLimit, stTargetState.rPosition - stTargetState.rTolerance);
ELSE
	//Calculate the limit positions for MPS based on current state
	lrMPSUpperLimit := lrLatchedTargetPosition + lrLatchedTargetTolerance;
	lrMPSLowerLimit := lrLatchedTargetPosition - lrLatchedTargetTolerance;
END_IF

//MPS Faults
//Fault if the beam is unsafe for current state
xBeamParamsOOS := NOT F_SafeBPCompare(PMPS_GVL_BeamParams.stCurrentBeamParameters, stLatchedBeamParams);

//Fault if the position is outside of the permitted range
xActuatorOOB := lrPosition >= lrMPSUpperLimit OR lrPosition <= lrMPSLowerLimit;



//Latch the MPS faults
srMPSFault.SET1 := xActuatorOOB OR xBeamParamsOOS OR xStateLookupError;
srMPSFault(RESET:=i_xResetMPSFault); 

(* Note: The state lookup error is recoverable, because a different target state might be valid.
*)


//MPS override
(* In override mode, the device will be free to move anywhere within it's travel range *)
//Permit motion after a small delay
tonMPSOverrideMode(IN:=i_xMPSOverride OR stDevice.xOverrideMPSLimits);

//Virtual limit switch evaluation
xActuatorPositiveEnable	:= stDevice.i_xHiLim AND lrPosition <= stDevice.lrUpperPositionLimit;
xActuatorNegativeEnable	:= stDevice.i_xLoLim AND lrPosition >= stDevice.lrLowerPositionLimit;

//Evaluate MPS limit states
xMPSPositiveEnable := lrPosition <= lrMPSUpperLimit;
xMPSNegativeEnable := lrPosition >= lrMPSLowerLimit;

//Final Limit switch evaluation
mcPower.Enable_Positive := xActuatorPositiveEnable AND (tonMPSOverrideMode.Q OR xMPSPositiveEnable);
mcPower.Enable_Negative := xActuatorNegativeEnable AND (tonMPSOverrideMode.Q OR xMPSNegativeEnable);

mcPower(
	Axis := stDevice.stAxis,
	Enable := stDevice.xEnable //link to device enable <TODO>
);

//An mcPower error or MPS override, or MPS fault, produces a fault.
q_xFault := mcPower.Error OR i_xMPSOverride OR srMPSFault.Q1 OR xInitFault;]]></ST>
    </Implementation>
    <LineIds Name="FB_LinearGovernor">
      <LineId Id="482" Count="1" />
      <LineId Id="615" Count="1" />
      <LineId Id="773" Count="1" />
      <LineId Id="606" Count="0" />
      <LineId Id="779" Count="0" />
      <LineId Id="791" Count="0" />
      <LineId Id="775" Count="0" />
      <LineId Id="605" Count="0" />
      <LineId Id="607" Count="0" />
      <LineId Id="781" Count="1" />
      <LineId Id="788" Count="0" />
      <LineId Id="684" Count="2" />
      <LineId Id="692" Count="0" />
      <LineId Id="688" Count="1" />
      <LineId Id="687" Count="0" />
      <LineId Id="789" Count="0" />
      <LineId Id="610" Count="0" />
      <LineId Id="621" Count="1" />
      <LineId Id="783" Count="2" />
      <LineId Id="608" Count="0" />
      <LineId Id="484" Count="8" />
      <LineId Id="702" Count="0" />
      <LineId Id="694" Count="2" />
      <LineId Id="707" Count="0" />
      <LineId Id="698" Count="1" />
      <LineId Id="697" Count="0" />
      <LineId Id="493" Count="12" />
      <LineId Id="582" Count="0" />
      <LineId Id="584" Count="20" />
      <LineId Id="583" Count="0" />
      <LineId Id="506" Count="13" />
      <LineId Id="544" Count="12" />
      <LineId Id="704" Count="0" />
      <LineId Id="703" Count="0" />
      <LineId Id="705" Count="0" />
      <LineId Id="557" Count="24" />
      <LineId Id="86" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>