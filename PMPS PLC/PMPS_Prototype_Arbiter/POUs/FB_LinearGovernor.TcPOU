<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.12">
  <POU Name="FB_LinearGovernor" Id="{ef40f951-1e56-0d26-34ec-87da9b08d3b7}" SpecialFunc="None">
    <Declaration><![CDATA[
(* The governor is meant to check your work and keep you from making mistakes.

Checks:
Does your state match the device position and visa versa?
Are the beam parameters safe for the device state?
Did you properly assert the transition and final beam parameters?

This is done by 

*)
FUNCTION_BLOCK FB_LinearGovernor
VAR_INPUT
	i_stCurrentBeamParams	:	ST_BeamParams; //Link to global beam params
	i_xMPSOverride			:	BOOL; //True releases MPS limits after a delay
	i_xTransitionRequested	:	BOOL; //Set true to request a transition
	i_xResetMPSFault	:	BOOL; //Set true to clear MPS fault 
END_VAR
VAR_OUTPUT
	q_xTransitionPermitted	:	BOOL; //True when governor has released restrictions
	q_xFault	:	BOOL; //Set if MC_Power has an error, or override mode is requested
END_VAR
VAR_IN_OUT
	stDevice	:	ST_Device; //The governed
	Arbiter	:	FB_Arbiter;
END_VAR
VAR
	mcPower	:	MC_Power;
	
	xActuatorPositiveEnable: BOOL;
	xActuatorNegativeEnable: BOOL;
	
	xMPSPositiveEnable	:	BOOL;
	xMPSNegativeEnable	:	BOOL;
	lrPosition: LREAL;
	
	lrLatchedTargetPosition	:	LREAL;
	lrLatchedTargetTolerance	:	LREAL;
	
	lrMPSUpperLimit: LREAL;
	lrMPSLowerLimit: LREAL;
	rtNewState: R_TRIG;
	xTransitionOK: BOOL;
	
	tonMPSOverrideMode	:	TON := (
		PT := T#5S
	);
	
	srMPSFault	:	SR;
	// Actuator out of bounds fault
	xActuatorOOB: BOOL;
	//Beam parameters out of spec
	xBeamParamsOOS: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
lrPosition := stDevice.stAxis.NcToPlc.ActPos;

//MPS Faults
//Fault if the beam is unsafe for current state
xBeamParamsOOS := NOT F_SafeBPCompare(PMPS_GVL_BeamParams.stCurrentBeamParameters, stBeamParamsOfCurrentState);

//Fault if the position is outside of the permitted range
//Allow for transitions
IF xTransitionOK THEN
	//Extend range to include target state
ELSE
	//Calculate the limit positions for MPS based on current state
	lrMPSUpperLimit := lrLatchedTargetPosition + lrLatchedTargetTolerance/2;
	lrMPSLowerLimit := lrLatchedTargetPosition - lrLatchedTargetTolerance/2;
END_IF

//Latch the MPS fault
srMPSFault.SET1 := xActuatorOOB;
srMPSFault(RESET:=i_xResetMPSFault); 

//MPS limit switch logic


//Evaluate MPS limit states
xMPSPositiveEnable := lrPosition <= lrMPSUpperLimit;
xMPSNegativeEnable := lrPosition >= lrMPSLowerLimit;

//Determine if the MPS limits can be lifted
IF i_xTransitionRequested THEN
	Arbiter.A_VerifyAssertion(
		i_nStateID := stDevice.stTransitionState.nStateRef
	);
	xTransitionOK := Arbiter.q_xStateIDFound;
ELSE
	xTransitionOK := FALSE;
END_IF

//MPS override
(* In override mode, the device will be free to move anywhere within it's travel range *)
//Permit motion after a small delay
tonMPSOverrideMode(IN:=i_xMPSOverride);

//Virtual limit switch evaluation
xActuatorPositiveEnable	:= stDevice.i_xHiLim AND lrPosition <= stDevice.lrUpperPositionLimit;
xActuatorNegativeEnable	:= stDevice.i_xLoLim AND lrPosition <= stDevice.lrLowerPositionLimit;

//Final Limit switch evaluation
mcPower.Enable_Positive := xActuatorPositiveEnable AND (tonMPSOverrideMode.Q OR xMPSPositiveEnable);
mcPower.Enable_Negative := xActuatorNegativeEnable AND (tonMPSOverrideMode.Q OR xMPSNegativeEnable);

mcPower(
	Axis := stDevice.stAxis,
	Enable := stDevice.xEnable //link to device enable <TODO>
);

//An mcPower error or MPS override, or MPS fault, produces a fault. Faults can be masked by veto devices.
q_xFault := mcPower.Error OR i_xMPSOverride OR srMPSFault.Q1;]]></ST>
    </Implementation>
    <LineIds Name="FB_LinearGovernor">
      <LineId Id="127" Count="1" />
      <LineId Id="172" Count="1" />
      <LineId Id="197" Count="0" />
      <LineId Id="211" Count="0" />
      <LineId Id="198" Count="0" />
      <LineId Id="174" Count="1" />
      <LineId Id="177" Count="0" />
      <LineId Id="179" Count="0" />
      <LineId Id="188" Count="0" />
      <LineId Id="190" Count="1" />
      <LineId Id="189" Count="0" />
      <LineId Id="180" Count="0" />
      <LineId Id="186" Count="0" />
      <LineId Id="176" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="130" Count="1" />
      <LineId Id="134" Count="16" />
      <LineId Id="187" Count="0" />
      <LineId Id="151" Count="16" />
      <LineId Id="86" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>