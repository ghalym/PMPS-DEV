<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_LinearGovernor" Id="{ef40f951-1e56-0d26-34ec-87da9b08d3b7}" SpecialFunc="None">
    <Declaration><![CDATA[
(* The governor is meant to check your work and keep you from making mistakes.

Checks:
Does your state match the device position and visa versa?
Are the beam parameters safe for the device state?
Did you properly assert the transition and final beam parameters?

*)
FUNCTION_BLOCK FB_LinearGovernor
VAR_INPUT
	i_stCurrentBeamParams	:	ST_BeamParams; //Link to global beam params
	i_xMPSOverride			:	BOOL; //True releases MPS limits after a delay
	i_xTransitionRequested	:	BOOL; //Set true to request a transition
	i_xResetMPSFault	:	BOOL; //Set true to clear MPS fault 
END_VAR
VAR_OUTPUT
	q_xTransitionPermitted	:	BOOL; //True when governor has released restrictions
	q_xFault	:	BOOL; //Set if MC_Power has an error, or override mode is requested
	// Indicates override mode is active
	q_xMPSLimitsOverridden: BOOL;
END_VAR
VAR_IN_OUT
	stDevice	:	ST_Device; //The governed
	Arbiter	:	FB_Arbiter;
END_VAR
VAR
	mcPower	:	MC_Power;
	
	xActuatorPositiveEnable: BOOL;
	xActuatorNegativeEnable: BOOL;
	
	xMPSPositiveEnable	:	BOOL;
	xMPSNegativeEnable	:	BOOL;
	lrPosition: LREAL;
	
	lrLatchedTargetPosition	:	LREAL;
	lrLatchedTargetTolerance	:	LREAL;
	
	lrMPSUpperLimit: LREAL;
	lrMPSLowerLimit: LREAL;
	rtNewState: R_TRIG;
	xTransitionOK: BOOL;
	
	tonMPSOverrideMode	:	TON := (
		PT := T#5S
	);
	
	srMPSFault	:	SR;
	// Actuator out of bounds fault
	xActuatorOOB: BOOL;
	//Beam parameters out of spec
	xBeamParamsOOS: BOOL;
	//Beam parameters of currently latched state
	
	stLatchedBeamParams: ST_BeamParams;
	stTargetState: ST_DeviceState;
	
	rtLatchNewState	:	R_TRIG;
	xInit: BOOL := TRUE;
	
	stInitDeviceState: ST_DeviceState;
	// Indicates an error with initialization
	xInitFault: BOOL;
	// Indicates the state could not be found in the state table. There may be something wrong in the device state machine implementation or state table instantiation.
	xStateLookupError: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
lrPosition := stDevice.stAxis.NcToPlc.ActPos; //Actuator position

stDevice.stAxis.ReadStatus();
//Init
(* The init strategy is:
If the device is restored and it's residing at the safe position,
no PMPS faults. *)
////////////////////////////////
	IF xInit THEN
		xInit := FALSE;
		//Use nSafeSate for initialization. 
		stDevice.StateTable.A_Lookup(key := stDevice.nSafeState);
		IF stDevice.StateTable.bOk THEN
			stInitDeviceState := stDevice.StateTable.getValue;
			xInitFault := FALSE;
		ELSE
			xInitFault := TRUE;
		END_IF
		lrLatchedTargetPosition := stInitDeviceState.rPosition;
		lrLatchedTargetTolerance := stInitDeviceState.rTolerance;
		stLatchedBeamParams := stInitDeviceState.stReqBeamParam;
	END_IF

// The governor will permit transitions once it verifies the transition assertion is active
// Note the governor does not verify the target state beam params are asserted, perhaps it should <TODO>
////////////////////////////////
	IF i_xTransitionRequested THEN
		Arbiter.A_VerifyAssertion(
			i_nStateID := stDevice.stTransitionState.nStateRef
		);
		xTransitionOK := Arbiter.q_xStateIDFound AND F_SafeBPCompare(PMPS_GVL_BeamParams.stCurrentBeamParameters, stDevice.stTransitionState.stReqBeamParam);
		
		//Set the target state for evaluation in further logic
		stdevice.StateTable.A_Lookup(key := stDevice.nTargetState);
		IF stDevice.StateTable.bOk THEN
			stTargetState := stDevice.StateTable.getValue;
			xStateLookupError := FALSE;
		ELSE
			xStateLookupError := TRUE;
		END_IF
	ELSE
		xTransitionOK := FALSE;
	END_IF

(* Note about TransitionRequested

If TransitionRequested goes false during a transition, an MPS fault may be induced. This occurs
because the Actuator Out of Bounds fault will go back to using the original state limits, which
the axis may have already moved beyond.

To avoid this transient fault, make sure your device state machine is implemented such that the 
transition request to the governor block remains high until the target position is reached.
*)

//Determine if a transition is complete and latch the new state
(* A transition is complete when:

Axis at standstill.
Axis within tolerance.
No transition req.

Once these conditions are met, the MPS limits shall re-engage to restrict the
axis motion to the tolerance around the state position and the MPS fault monitors
shall evaluate based on the newly latched target state.
*)

rtLatchNewState(CLK := stDevice.stAxis.Status.StandStill AND
	lrPosition <= stTargetState.rPosition + stTargetState.rTolerance AND
	lrPosition >= stTargetState.rPosition - stTargetState.rTolerance AND
	NOT i_xTransitionRequested);
	
IF rtLatchNewState.Q THEN
	lrLatchedTargetPosition := stTargetState.rPosition;
	lrLatchedTargetTolerance := stTargetState.rTolerance;
	stLatchedBeamParams := stTargetState.stReqBeamParam;
END_IF

//Let other blocks know the governor won't interfer with transitions
q_xTransitionPermitted := xTransitionOK;

//Adjust limit ranges based on active state and current target
IF xTransitionOK THEN
	//Extend range to include target state
	lrMPSUpperLimit := MAX(lrMPSUpperLimit, stTargetState.rPosition + stTargetState.rTolerance);
	lrMPSLowerLimit := MIN(lrMPSLowerLimit, stTargetState.rPosition - stTargetState.rTolerance);
ELSE
	//Calculate the limit positions for MPS based on current state
	lrMPSUpperLimit := lrLatchedTargetPosition + lrLatchedTargetTolerance;
	lrMPSLowerLimit := lrLatchedTargetPosition - lrLatchedTargetTolerance;
END_IF

//MPS Faults
//Fault if the beam is unsafe for current state
xBeamParamsOOS := NOT F_SafeBPCompare(PMPS_GVL_BeamParams.stCurrentBeamParameters, stLatchedBeamParams);

//Fault if the position is outside of the permitted range
xActuatorOOB := lrPosition >= lrMPSUpperLimit OR lrPosition <= lrMPSLowerLimit;



//Latch the MPS faults
srMPSFault.SET1 := xActuatorOOB OR xBeamParamsOOS OR xStateLookupError;
srMPSFault(RESET:=i_xResetMPSFault); 

(* Note: The state lookup error is recoverable, because a different target state might be valid.
*)


//MPS override
(* In override mode, the device will be free to move anywhere within it's travel range *)
//Permit motion after a small delay
tonMPSOverrideMode(IN:=i_xMPSOverride OR stDevice.xOverrideMPSLimits, Q=>q_xMPSLimitsOverridden);

//Virtual limit switch evaluation
xActuatorPositiveEnable	:= stDevice.i_xHiLim AND lrPosition <= stDevice.lrUpperPositionLimit;
xActuatorNegativeEnable	:= stDevice.i_xLoLim AND lrPosition >= stDevice.lrLowerPositionLimit;

//Evaluate MPS limit states
xMPSPositiveEnable := lrPosition <= lrMPSUpperLimit;
xMPSNegativeEnable := lrPosition >= lrMPSLowerLimit;

//Final Limit switch evaluation
mcPower.Enable_Positive := xActuatorPositiveEnable AND (tonMPSOverrideMode.Q OR xMPSPositiveEnable);
mcPower.Enable_Negative := xActuatorNegativeEnable AND (tonMPSOverrideMode.Q OR xMPSNegativeEnable);

mcPower(
	Axis := stDevice.stAxis,
	Enable := stDevice.xEnable //link to device enable <TODO>
);

//An mcPower error or MPS override, or MPS fault, produces a fault.
q_xFault := mcPower.Error OR i_xMPSOverride OR srMPSFault.Q1 OR xInitFault;]]></ST>
    </Implementation>
    <LineIds Name="FB_LinearGovernor">
      <LineId Id="924" Count="3" />
      <LineId Id="1118" Count="2" />
      <LineId Id="928" Count="2" />
      <LineId Id="1117" Count="0" />
      <LineId Id="931" Count="120" />
      <LineId Id="86" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>